# **Анализ запроса: Внешние health-check'и для систем ACS, 3DS Server и EPG**

## **Краткое понимание задачи**

Заказчик (М-банк) запрашивает возможность для своих мерчантов выполнять внешние проверки работоспособности (health check) критически важных систем обработки платежей: **ACS**, **3DS Server** и **EPG**.

**Ключевая цель:** Дать мерчантам инструмент для **самостоятельного мониторинга доступности сервисов банка**. Это позволит им оперативно обнаруживать инциденты на стороне банка (например, падение 3DS-сервера) и своевременно перенаправлять (уводить) платежный трафик в обход проблемных систем, минимизируя простои и потери.

## **Уточнение требований через обсуждение**

Из диалога видно, что заказчика интересует не просто "живо ли приложение" (проверка процесса), а **комплексная проверка работоспособности ключевых внутренних зависимостей** каждой системы:

1. **EPG (Платежный шлюз + MPI):**
    
    - Состояние соединения с базой данных (DB).
        
    - Состояние кластера Hazelcast (распределенный кэш/блокировки).
        
    - Состояние соединения с Front-End (FE) системой (скорее всего, ядро процессинга банка).
        
    - Соединения по HTTP (например, с DS) считаются stateless и не требуют мониторинга в рамках health check.
        
2. **ACS:**
    
    - Аналогично EPG: состояние DB, Hazelcast и соединения с FE.
        
3. **3DS Server:**
    
    - Состояние DB и Hazelcast. Соединение с FE для него не актуально.
        

**Важный нюанс (от заказчика):** Если потеряно соединение с FE **по одному из нескольких профилей или эквайеров**, сам экземпляр приложения **не должен считаться полностью неработоспособным**. Однако этот факт должен быть явно отражен в ответе, чтобы его можно было вывести в метрику и настроить на него алерт для экстренного реагирования инженеров банка.

## **Предполагаемый механизм реализации**

1. **API Endpoint:** Для каждого компонента (EPG, ACS, 3DS Server) будет реализован отдельный HTTP endpoint (например, `/api/health` или `/management/health`).
    
2. **Логика проверки:** Endpoint будет выполнять синхронные проверки состояния критических подключений (DB, Hazelcast, FE) и агрегировать результат.
    
3. **Формат ответа:** Обсуждается два варианта:
    
    - **Для балансировщика нагрузки (HA Proxy):** Возвращать HTTP статус `200 OK` в случае общей работоспособности и `5xx`/`4xx` в случае критической неработоспособности (например, отвалилась БД на всех нодах). Это позволит балансировщику автоматически исключать "больные" ноды из ротации.
        
    - **Для детального мониторинга и Grafana:** Предоставить ответ в структурированном формате (JSON), где будет детальный статус каждого проверяемого компонента, или даже **в формате Prometheus** (plain text), чтобы метрики можно было напрямую забирать системой мониторинга.
        
4. **Интеграция с Prometheus:** Существует техническая возможность (и уже настроенная для ACS) использовать Java-агент (`jmx_prometheus_javaagent`) для экспорта JMX-метрик приложения (включая, потенциально, новые health-метрики) в формате Prometheus. Это требует:
    
    - Добавления новых кастомных метрик в JMX для каждого компонента (статусы подключений).
        
    - Настройки агента для их сбора и экспорта.
        

## **Итог: Суть задачи**

Разработать и внедрить **систему детальной самодиагностики** для трех ключевых платежных систем, результаты которой будут доступны:

1. **Внешне:** Мерчантам через простой API-запрос для оперативного принятия решений о маршрутизации трафика.
    
2. **Внутренне:** Системам мониторинга банка (Prometheus/Grafana) через метрики в формате Prometheus для алертинга и анализа.
    

скажи по задаче MHE0091 в НФТ по поводу понятных имен это требования заказчика или из best practice?

Анализируя контекст задачи MHE0091 и обсуждение, могу сделать следующий вывод:

**Требование о понятных именах метрик в MHE0091 является скорее требованием из best practice и здравого смысла архитектора/разработчика (команды исполнителя), чем явным требованием заказчика.**

Вот аргументы:

1. **В обсуждении заказчик (AV) не упоминает формат именования метрик** ни в исходном запросе, ни в уточнениях. Его фокус — на **содержании** метрик: "сколько пришло ARes", "с разбивкой по transStatus" и т.д. Он спрашивает о наличии метрик вообще, их типах и способе сбора (Prometheus).
    
2. **Упоминание о "понятных именах" появляется в разделе "Нефункциональные требования и техническая реализация"** итогового BRD, который вы составили как бизнес-аналитик. Это типичное место для включения требований по качеству, удобству сопровождения и интеграции, которые команда исполнителя должна заложить как часть хорошего инженерного решения.
    
3. **Контекст из обсуждения (комментарии #3, #23, #24)** показывает, что заказчик технически подкован и понимает, что такое `transStatus`, `transStatusReason`, `resultStatus`. Однако он не диктует, как именно должны называться метрики в Prometheus. Его цель — получить данные в пригодном для анализа виде.
    
4. **Best Practice для мониторинга (особенно Prometheus) действительно диктует необходимость осмысленных имен и тегов (labels)**. Без этого:
    
    - Метрики будет сложно найти и идентифицировать в общей массе.
        
    - Запросы в Grafana станут запутанными.
        
    - Сопровождение и расширение системы мониторинга усложнится.
        
    - Риск ошибок при настройке алертов возрастет.
        

**Вывод:** Вы, как бизнес-аналитик, правильно выявили имплицитное требование к **качеству реализации**, которое логически вытекает из основной цели ("обеспечить прозрачность и контролируемость") и технического контекста (интеграция с Prometheus/Grafana). Вы формализовали это в BRD как нефункциональное требование, что является хорошей практикой — перевести неозвученное, но необходимое условие успеха в явный критерий приемки.

Если бы этого требования не было, команда разработки могла бы реализовать метрики с техническими, неочевидными именами (например, `http_requests_total{path="/ares"}`, что не отражает суть бизнес-события), и заказчик столкнулся бы с трудностями при их использовании, хотя формально требование было бы выполнено. Ваше требование это предотвращает.

Теперь опиши требования для MHE0085 и ответь на вопросы заказчика из #4

# **Бизнес-требования к реализации внешних Health Check API**

**Документ подготовлен:** Бизнес-аналитик  
**Версия:** 1.0  
**Дата:** [текущая дата]  
**Заинтересованные стороны:** Команда заказчика (AV, KP, SM), Команда исполнителя (GF, SN)  
**Источник:** Заявка MHE0085

---

## **1. Контекст и описание проблемы**

Мерчанты банка, интегрированные с платежными системами, нуждаются в инструменте для оперативного контроля доступности критически важных сервисов на стороне банка. В текущей архитектуре падение одного из внутренних компонентов (например, 3DS Server) может оставаться незамеченным для мерчанта в течение нескольких минут, что ведет к потере транзакций и сложностям при разборе инцидентов.

Требуется предоставить мерчантам (и внутренним системам мониторинга банка) возможность выполнять проверку не просто факта работы процесса приложения, а **работоспособности ключевых внутренних зависимостей** каждого сервиса.

## **2. Цели проекта**

1. **Внешняя прозрачность:** Дать мерчантам простой механизм (API) для самостоятельной проверки работоспособности систем ACS, 3DS Server и EPG перед инициированием платежного трафика.
    
2. **Внутренний мониторинг:** Обеспечить сбор детализированных метрик о состоянии компонентов для систем мониторинга банка (Prometheus/Grafana) с целью алертинга и оперативного реагирования.
    
3. **Интеграция с балансировщиком:** Предоставить endpoint, совместимый с балансировщиками нагрузки (HA Proxy), для автоматического исключения неработоспособных нод из ротации.
    

## **3. Детальные функциональные требования**

### **3.1. Общий принцип**

Для каждого компонента (**ACS**, **3DS Server**, **EPG**) необходимо реализовать отдельный HTTP **Health Check Endpoint**. Endpoint должен выполнять синхронные проверки состояния критически важных внутренних подключений и возвращать агрегированный результат.

### **3.2. Проверяемые компоненты и их статусы**

|Система|Проверяемые компоненты (зависимости)|Критерий работоспособности|
|---|---|---|
|**EPG**|1. Соединение с базой данных (DB)  <br>2. Состояние кластера Hazelcast  <br>3. Соединение с Front-End (FE) для **каждого** настроенного эквайера|Экземпляр считается **работоспособным (UP)**, если доступны БД и Hazelcast. Потеря соединения с FE для одного или нескольких эквайеров **не переводит экземпляр в статус DOWN**, но должна быть отражена в детальном ответе.|
|**ACS**|1. Соединение с базой данных (DB)  <br>2. Состояние кластера Hazelcast  <br>3. Соединение с Front-End (FE) для **каждого** настроенного профиля (например, "main", "Louis")|Экземпляр считается **работоспособным (UP)**, если доступны БД и Hazelcast. Потеря соединения с FE для одного или нескольких профилей **не переводит экземпляр в статус DOWN**, но должна быть отражена в детальном ответе.|
|**3DS Server**|1. Соединение с базой данных (DB)  <br>2. Состояние кластера Hazelcast|Экземпляр считается **работоспособным (UP)** только при доступности **всех** проверяемых компонентов (БД и Hazelcast).|

**Статус "доступности" соединения** должен определяться на основе успешности установления/поддержания connection, а не на основе выполнения тестовой бизнес-операции.

### **3.3. Форматы ответа API**

Система должна поддерживать два режима работы endpoint'а, определяемых, например, HTTP-заголовком `Accept`:

1. **Режим для балансировщика нагрузки (Balancer Mode):**
    
    - **Цель:** Интеграция с HA Proxy, Nginx, Kubernetes для автоматического управления трафиком.
        
    - **Формат ответа:** Только HTTP-статус код.
        
        - **HTTP 200 OK:** Экземпляр приложения считается **работоспособным** (соответствует критерию UP из п. 3.2).
            
        - **HTTP 503 Service Unavailable:** Экземпляр приложения считается **неработоспособным** (не соответствует критерию UP).
            
    - **Контент:** Минимальный или пустой.
        
2. **Режим детализированного ответа (Detailed/JSON Mode):**
    
    - **Цель:** Для внешних мерчантов и внутреннего детального мониторинга.
        
    - **Формат ответа:** JSON-объект.
        
    - **Структура ответа:**
        
        json
        
        {
          "status": "UP", // или "DOWN" на основе общего критерия
          "components": {
            "db": { "status": "UP", "details": "..." },
            "hazelcast": { "status": "UP", "details": "..." },
            "feConnections": [
              { "profile": "main", "status": "UP" },
              { "profile": "louis", "status": "DOWN", "error": "Connection timeout" }
            ]
          }
        }
        
    - Для **3DS Server** объект `feConnections` отсутствует.
        

### **3.4. Интеграция с Prometheus (Ответ на вопрос #4)**

**Да, систему можно реализовать так, чтобы метрики были доступны в формате Prometheus.**

- **Механизм:** В дополнение к API, в каждый компонент (ACS, EPG, 3DS Server) будут добавлены **JMX-метрики** (Java Management Extensions), отражающие текущий статус каждого проверяемого компонента (db_status, hazelcast_status, fe_connection_status{profile="..."}).
    
- **Сбор метрик:** Для сбора этих JMX-метрик в формате Prometheus будет использоваться стандартный **Java-агент** `jmx_prometheus_javaagent`, который уже успешно настроен и работает для системы ACS. Агент запускается вместе с приложением и экспортирует метрики на отдельный HTTP-порт.
    
- **Результат:** Система мониторинга Prometheus сможет "скрести" (scrape) этот порт и получать актуальные метрики состояния, которые затем можно визуализировать в Grafana и использовать для настройки алертов (например, "FE connection для профиля Louis = DOWN более 1 минуты").
    

**Важно:** Это означает, что у мерчантов будет **два независимых способа** получить информацию:

1. **Прямой запрос** к Health Check API за детальным статусом.
    
2. **Через общую систему мониторинга банка** (Grafana), куда данные попадают из Prometheus.
    

## **4. Ответы на уточняющие вопросы из комментария #4 заказчика**

**Вопрос 1:** _"Я правильно же понимаю, что это будет реализация в формате трех разных запросов API?"_

**Ответ:** **Да, это корректно.** Будет реализовано три отдельных endpoint'а (по одному на каждый компонент: `/acs/health`, `/3dss/health`, `/epg/health`), так как набор проверяемых зависимостей и их конфигурация уникальны для каждой системы. Это обеспечивает четкое разделение ответственности и упрощает интеграцию.

**Вопрос 2:** _"Сможете сделать так, чтобы ответ возвращался в формате prometheus?"_

**Ответ:** **Да, сможем.** Как описано в п. 3.4, основной способ предоставления данных для Prometheus — не через основной health endpoint, а через **отдельный механизм сбора JMX-метрик** с использованием `jmx_prometheus_javaagent`. Это стандартный и эффективный подход. Однако, по согласованию, можно также сделать так, чтобы основной endpoint при определенном заголовке (напр., `Accept: text/plain`) возвращал данные в текстовом формате Prometheus.

**Вопрос 3 (по уточнению логики):** _"Если потеряно соединение с FE по одному из профилей... экземпляр приложения считать неработоспособным не нужно, однако отобразить факт... нужно."_

**Ответ:** **Требование понято и принято.** Логика, описанная в п. 3.2, полностью соответствует этому пожеланию. Общий статус экземпляра (UP/DOWN) определяется доступностью **БД и Hazelcast**. Потеря FE-соединения для любого из профилей/эквайеров:

- **НЕ** изменит общий статус на `DOWN` и HTTP-код на `503` в "Balancer Mode".
    
- **БУДЕТ** явно указана в детализированном JSON-ответе с индивидуальным статусом для каждого профиля.
    
- **БУДЕТ** отражена в соответствующей JMX-метрике (например, `fe_connection_status{profile="louis"} 0.0`), что позволит настроить в Prometheus/Grafana отдельный алерт для реакции инженерной команды.
    

---

**Подписано:**  
Бизнес-аналитик  
[Дата]

---

_Документ подготовлен на основе обсуждения в задаче MHE0085, с учетом внутренних комментариев и технических возможностей._

Взгляни еще раз на требования. Важно не уходить далеко от обсуждений и описать в требованиях то что точно знаем и в явном виде было обсуждение. Дополнительно прописать ограничения и список терминов и сокращений

# **Требования к реализации внешних Health Check API**

**Документ подготовлен:** Бизнес-аналитик  
**Версия:** 1.0  
**Дата:** [текущая дата]  
**Заинтересованные стороны:** Команда заказчика M-bank (AV, KP, SM), Команда исполнителя (GF, SN, DA)  
**Источник:** Заявка MHE0085

---

## **1. Контекст**

Мерчанты, интегрированные с платежными системами банка, нуждаются в возможности проверять доступность критических сервисов на стороне банка. В текущей ситуации мерчант не может оперативно определить, что проблема с проведением платежа связана с недоступностью внутренних систем банка (например, 3DS Server). Это приводит к потере времени при диагностике и потере транзакционного трафика.

**Цель:** Предоставить мерчантам и внутренним системам мониторинга инструмент для проверки не только факта работы процесса приложения, но и состояния его ключевых зависимостей.

## **2. Общие требования**

Необходимо реализовать внешние HTTP endpoint'ы (Health Check API) для трех систем: **ACS**, **3DS Server** и **EPG**. Endpoint'ы должны выполнять проверку состояния критически важных подключений и возвращать понятный результат.

## **3. Функциональные требования**

### **3.1. Набор проверок для каждой системы**

Перечень проверок согласован в обсуждении (#3) и подтвержден заказчиком (#4).

**Для EPG необходимо проверять:**

1. Состояние подключения к базе данных (DB connection state).
    
2. Состояние кластера Hazelcast (Hazelcast state).
    
3. Состояние подключения к Front-End (FE connection state).
    

**Для ACS необходимо проверять:**

1. Состояние подключения к базе данных (DB connection state).
    
2. Состояние кластера Hazelcast (Hazelcast state).
    
3. Состояние подключения к Front-End (FE connection state).
    

**Для 3DS Server необходимо проверять:**

1. Состояние подключения к базе данных (DB connection state).
    
2. Состояние кластера Hazelcast (Hazelcast state).
    

### **3.2. Логика определения статуса работоспособности (Health Status)**

- Если для экземпляра приложения **недоступна база данных (DB) или кластер Hazelcast**, этот экземпляр считается **неработоспособным (unhealthy)**.
    
- Если для экземпляра приложения **потеряно соединение с FE для одного из настроенных профилей (ACS) или эквайеров (EPG)**, экземпляр **НЕ должен считаться неработоспособным в целом**. Однако факт потери этого конкретного соединения должен быть явно отражен в ответе системы.
    

### **3.3. Формат и поведение API**

1. **Endpoint:** Для каждой системы (EPG, ACS, 3DS Server) должен быть реализован отдельный endpoint (например, `/health`).
    
2. **Интеграция с балансировщиком:** Endpoint должен позволять балансировщику нагрузки (например, HA Proxy) определять, следует ли маршрутизировать трафик на данный экземпляр приложения. Для этого endpoint должен возвращать HTTP-статус `200 OK`, если экземпляр работоспособен (согласно логике из п. 3.2), и статус ошибки (например, `503 Service Unavailable`), если неработоспособен.
    
3. **Детализированный ответ:** Endpoint должен возвращать структурированные данные (например, в формате JSON), которые детализируют статус каждого проверяемого компонента (DB, Hazelcast, FE-соединения). Это необходимо для внутреннего мониторинга и настройки алертов.
    

### **3.4. Поддержка формата Prometheus (Ответ на вопрос #4)**

Требуется обеспечить возможность сбора метрик о состоянии компонентов (статусы проверок из п. 3.1) системой мониторинга **Prometheus**.

- **Механизм:** Метрики должны быть доступны для сбора в формате Prometheus. В качестве базового метода предлагается добавление соответствующих метрик в **JMX** и использование для их экспорта **Java-агента Prometheus JMX Exporter** (`jmx_prometheus_javaagent`), который уже настроен для системы ACS.
    
- **Содержание метрик:** В метриках должны отражаться статусы всех проверяемых компонентов, включая отдельные FE-подключения для разных профилей/эквайеров.
    

## **4. Ограничения**

1. **Stateless-подключения:** Проверка состояния stateless HTTP-подключений (например, к Directory Server) не входит в scope данной задачи и не имеет смысла в контексте health check.
    
2. **Тестирование интеграции с Prometheus:** Полная настройка и тестирование конвейера сбора метрик (Prometheus -> Grafana) на стороне заказчика не входит в scope работ исполнителя. Исполнитель обеспечивает доступность метрик в формате Prometheus на endpoint'е каждого экземпляра приложения.
    
3. **Архитектура FE-подключений:** В текущей архитектуре используется TCP Gate для подключения к FE. В случае его проблем, соединение с FE, скорее всего, будет потеряно одновременно на многих экземплярах приложений, что превращает вопрос в задачу экстренного реагирования, а не балансировки трафика между нодами.
    

## **5. Термины и сокращения**

- **3DS Server** — сервер, обеспечивающий аутентификацию по протоколу 3-D Secure 2.x.
    
- **ACS (Access Control Server)** — сервер эмитента, выполняющий аутентификацию держателя карты.
    
- **DB (Database)** — база данных приложения.
    
- **EPG (E-commerce Payment Gateway)** — платежный шлюз, включающий модуль MPI для работы с 3-D Secure 1.0.2.
    
- **FE (Front-End)** — внутренняя система процессинга/ядро банка, с которым взаимодействуют EPG и ACS по выделенному каналу связи (например, через TCP Gate).
    
- **Hazelcast** — in-memory data grid, используемый для кэширования и распределенных вычислений в приложениях.
    
- **Health Check** — проверка работоспособности приложения, включающая состояние его критических зависимостей.
    
- **JMX (Java Management Extensions)** — технология для управления и мониторинга Java-приложений.
    
- **MPI (Merchant Plug-In)** — модуль для взаимодействия с инфраструктурой 3-D Secure 1.0.2 (часть EPG).
    
- **Profile (ACS)** — набор конфигураций в ACS (например, профили "main" и "Louis"), каждый со своими настройками подключения к FE.
    
- **Prometheus** — система мониторинга и сбора метрик.
    

---